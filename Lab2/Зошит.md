
        Лабораторна робота №2(10 + 10 балів)
        Тема: Побудова спрощенного синтаксичного аналізатора
        Завдання

        Для даної граматики  написати аналізатор, що діє методом рекурсивного спуска.

        Створити файл з реченнями, належними і не належними мові граматики.Створений файл є вхідним файлом
        аналізатора.Кожне речення – окремий рядок, у частині речень зробити синтаксичні і лексичні помилки.
        2 речення w довжиною виведення k не менше п’яти(S = > k w) вивести у зошиті.

        Для одержання наступної лексеми речення створити окрему функцію get_token().

        Для речення з помилками передбачити видачу інформації про помилки,
        вказуючи номер рядка, позицію в ньому і суть помилки.

        Окремо протестувати функцію get_token().Для цього вивести у окремий файл лексеми
        у вигляді <номер  рядка, тип, лексема>.Типи лексем – невідома лексема, ідентифікатор,
        ключове слово, константа, символ, тег, знак, тощо.
        Можливі типи лексем для конкретного варіанту та їх приклади написати у зошиті.
        Зауваження: В умовах синім кольором виділені лексери
        (їм відповідають лексеми - регулярні вирази).IDEN, VALUE - також лексери.

        Приклад опису типів лексем і прототипу функції get_token() :

            enum Token // тип лексеми

        {

            ITER1,  // унарна операція *

            ITER2,  // унарна операція +

            RP,       //лексема )

            LP,        //лексема (

            ALT,      //бінарна операція |

            CONCAT,   //бінарна операція .

            OP,       //лексема операнду

            END      //лексема кінця речення

        };

        struct Lex {
            int num;  // номер речення
            Token token; // тип лексеми
            string value; // значення лексеми
        };

        Lex get_token(); // повертає лексему

        Алгоритм для функції main() :
            ...
            for (int i = 0; i < 5; i++) {// для кожного речення з вхідного файлу
                do {
                    ... // друк лексем у файл, друк повідомлень про помилки на  консоль
                } while (get_token().token != END);
            }

        Лабораторну роботу здавати в 2 єтапи: 2a(обов'язково), 2б( не обов'язково):

            2a.Робота з функцією get_token() без синтаксичного аналізу.
            На вхід програми подається файл з реченнями, 
            на виході отримується файл лексем, які утворилися з кожного речення 
            до першої прочитаної невідомої лексеми.

            У електронному робочому зошиті розмістити умову задачі(вхідну граматику), 
            типи лексем, 5 вхідних речень(вхідний файл) і містиме файлу з лексемами.

            2б.Синтаксичний аналіз методом рекурсивного спуску(для кожного нетерміналу 
            пишеться окрема функція).На вхід подається файл з вхідними реченнями або 
            файл з лексемами.На екран виводяться повідомлення про помилки лексичного і 
            синтаксичного аналізу для кожного окремого речення, а також висновки про
            належність речення мові граматики.


                9) S -> begin I = T {; I = T} end;

                T -> T*F | T/F | F

                I -> ab | ba

                C-> 10 | 100

                F -> I | I^C
                
                
          S-> begin I = T {; I = T} end; -> begin ab = T {; ba = T} end; -> 
          begin ab = T*F {; ba = T/F} end; -> begin ab = F*F {; ba = T*F/F}end; ->
          begin ab = I*I {; ba=I*I^C/I}end; -> begin ab = ab*ba {; ba = ba*ba^10/ab } end;
          
          S-> begin I = T {; I = T} end; -> begin ba=T*F {; ab = T/F}end; ->
           begin ba=F*F {; ab = F/F}end; -> begin ba=I*I^C {; ab = I/I}end; ->
            begin ba=ab*ba^100 {; ab = ba/ba}end;
          
          S-> begin I = T/F {; I = T*F} end; -> begin ab = T*F/F {; ba = F*F} end; ->
           begin ab = F*F/F {; ba = F*F} end; ->  begin ab = I*I^C/I {; ba = I^C*I^C} end; ->
            begin ab = ab*ba^10/ab {; ba = ab^100*ab^10} end; 
          
          S-> begin I = T {; I = T} end; -> begin ab = T/F {; ab = T*F} end; ->
           begin ab = T/F/F {; ab = T*F*F} end; -> begin ab = F/F/F {; ab =  F*F*F} end; ->
            begin ab = I/I/I {; ab =  I^C*I*I} end; -> begin ab = ab/ab/ab {; ab = ab^10*ab*ab} end;
          
           S-> begin I = T {; I = T} end; -> begin ba = T/F {; ab = T*F} end; ->
           begin ba = T*F/F {; ab = T/F*F} end; -> begin ba = F*F/F {; ab =  F/F*F} end; ->
            begin ba = I*I/I {; ab =  I^C/I*I} end; -> begin ba = ba*ab/ab {; ab = ab^10*ba*ab} end;
          
          
          ТИПИ ЛЕКСЕМ:
   ![уууу](https://github.com/lawfulolha/compilation-course-ss2021/blob/main/%D1%83%D1%83%D1%83%D1%83.png)
          
          
        begin ab = ab*ba {; ba = ba*ba^10/ab } end;
        pii
        begin ab=ba^10{; ab=ba^10 } end;
        begin ba=ab{; ba=1}end;
        begin ba = ba*ab/ab {; ab = ab^10*ba*ab} end;
        begin ab=ba^100{; ab=ba^100 } end;
        beg ab = ba
        begin ab = ab/ab/ab {; ab = ab^10*ab*ab} end;
        begin ab = ab*ba^10/ab {; ba = ab^100*ab^10} end;
        begin ba=ab*ba^100 {; ab = ba/ba}end;
        begin ba=ab*ba^100 { ab = ba/ba}end;
